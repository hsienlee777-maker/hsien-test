<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.5" />
    <title>喵咪539</title>
    <style>
      :root {
        --bg1: #ecfeff;
        --bg2: #eef2ff;
        --text: #0f172a;
        --panel: rgba(255, 255, 255, 0.9);
        --blue1: #2563eb;
        --blue2: #3b82f6;
        --orange1: #f59e0b;
        --orange2: #f97316;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: 'Noto Sans TC', 'PingFang TC', 'Microsoft JhengHei', system-ui, sans-serif;
        color: var(--text);
        background: radial-gradient(circle at top, var(--bg1), #f8fafc 45%, var(--bg2));
      }

      .app {
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 16px;
        padding: 24px 16px 36px;
      }

      h1 {
        margin: 0;
        font-size: clamp(1.6rem, 4vw, 2.1rem);
      }

      .panel {
        width: min(720px, 100%);
        border-radius: 16px;
        background: var(--panel);
        padding: 14px 16px;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.08);
      }

      .row-title {
        font-size: .95rem;
        color: #334155;
        margin-bottom: 10px;
      }

      .balls-row {
        min-height: 52px;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
      }

      .current-row { justify-content: center; }

      .ball {
        width: 44px;
        height: 44px;
        border-radius: 999px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        color: #fff;
        font-weight: 700;
        font-size: 1rem;
        background: linear-gradient(135deg, var(--orange1), var(--orange2));
        box-shadow: 0 8px 16px rgba(249, 115, 22, .28);
        user-select: none;
      }

      .ball.small {
        width: 38px;
        height: 38px;
        font-size: .9rem;
        box-shadow: 0 6px 12px rgba(249, 115, 22, .22);
      }

      .ball.enter {
        animation: pop-in .25s ease-out;
      }

      @keyframes pop-in {
        from { opacity: 0; transform: scale(.72) translateY(8px); }
        to { opacity: 1; transform: scale(1) translateY(0); }
      }

      .draw-button {
        width: 150px;
        height: 150px;
        border-radius: 999px;
        border: none;
        color: #fff;
        font-size: 1.35rem;
        font-weight: 800;
        letter-spacing: 1px;
        cursor: pointer;
        background: linear-gradient(145deg, var(--blue1), var(--blue2));
        box-shadow: 0 16px 35px rgba(37, 99, 235, .34);
        transition: transform .2s ease, opacity .2s ease;
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      .draw-button:hover:not(:disabled) { transform: translateY(-2px); }
      .draw-button:disabled { cursor: not-allowed; opacity: .6; }

      .hint {
        margin-top: -8px;
        font-size: .88rem;
        color: #475569;
      }

      .history-panel .balls-row + .balls-row { margin-top: 10px; }
      .empty-text { margin: 2px 0 0; color: #64748b; }
    </style>
  </head>
  <body>
    <main class="app">
      <h1>貓咪539</h1>

      <section class="panel">
        <div class="row-title">本輪號碼</div>
        <div id="currentRow" class="balls-row current-row"></div>
      </section>

      <button id="drawBtn" class="draw-button" type="button">抽號</button>
      <div class="hint">輕按：1 顆｜長按：5 顆</div>

      <section class="panel history-panel">
        <div class="row-title">歷史結果（最多 3 組）</div>
        <div id="history"></div>
      </section>
    </main>

    <script>
      const MAX_PER_ROUND = 5;
      const MAX_HISTORY = 3;
      const NUMBER_MIN = 1;
      const NUMBER_MAX = 39;
      const DRAW_DELAY = 260;
      const LONG_PRESS_MS = 500;
      const SORT_ANIM_MS = 800;

      const drawBtn = document.getElementById('drawBtn');
      const currentRow = document.getElementById('currentRow');
      const historyEl = document.getElementById('history');

      let currentRound = [];
      let history = [];
      let isLocked = false;
      let pressStartAt = null;
      let activePointerId = null;

      const sleep = (ms) => new Promise((resolve) => window.setTimeout(resolve, ms));

      function isRoundComplete() {
        return currentRound.length === MAX_PER_ROUND;
      }

      function getUniqueRandom(existing) {
        const pool = [];
        for (let i = NUMBER_MIN; i <= NUMBER_MAX; i += 1) {
          if (!existing.includes(i)) pool.push(i);
        }
        return pool[Math.floor(Math.random() * pool.length)];
      }

      function setButtonState() {
        drawBtn.textContent = isRoundComplete() ? '下一輪' : '抽號';
        drawBtn.disabled = isLocked;
      }

      function createBall(num, isSmall = false) {
        const ball = document.createElement('div');
        ball.className = `ball${isSmall ? ' small' : ''} enter`;
        ball.textContent = num;
        ball.dataset.num = String(num);
        return ball;
      }

      function renderCurrentRound(nums) {
        currentRow.innerHTML = '';
        nums.forEach((n) => currentRow.appendChild(createBall(n)));
      }

      function renderHistory() {
        historyEl.innerHTML = '';
        if (history.length === 0) {
          const p = document.createElement('p');
          p.className = 'empty-text';
          p.textContent = '尚無資料';
          historyEl.appendChild(p);
          return;
        }

        history.forEach((group) => {
          const row = document.createElement('div');
          row.className = 'balls-row';
          group.forEach((n) => row.appendChild(createBall(n, true)));
          historyEl.appendChild(row);
        });
      }

      function animateSortTo(sortedNums) {
        const before = new Map();
        Array.from(currentRow.children).forEach((el) => {
          before.set(el.dataset.num, el.getBoundingClientRect());
        });

        const byNum = new Map();
        Array.from(currentRow.children).forEach((el) => byNum.set(Number(el.dataset.num), el));
        sortedNums.forEach((n) => currentRow.appendChild(byNum.get(n)));

        Array.from(currentRow.children).forEach((el) => {
          const firstRect = before.get(el.dataset.num);
          const lastRect = el.getBoundingClientRect();
          const dx = firstRect.left - lastRect.left;
          const dy = firstRect.top - lastRect.top;

          if (dx !== 0 || dy !== 0) {
            el.animate(
              [
                { transform: `translate(${dx}px, ${dy}px)` },
                { transform: 'translate(0, 0)' }
              ],
              {
                duration: SORT_ANIM_MS,
                easing: 'cubic-bezier(0.22, 1.3, 0.3, 1)',
                fill: 'both'
              }
            );
          }
        });
      }

      function sortCurrentRoundWithAnimation() {
        const sorted = [...currentRound].sort((a, b) => a - b);
        animateSortTo(sorted);
        currentRound = sorted;
      }

      function startNextRound() {
        history = [[...currentRound], ...history].slice(0, MAX_HISTORY);
        currentRound = [];
        renderCurrentRound(currentRound);
        renderHistory();
      }

      async function drawMultiple(count) {
        if (isLocked || count <= 0) return;

        const remaining = MAX_PER_ROUND - currentRound.length;
        const drawCount = Math.min(count, remaining);
        if (drawCount <= 0) return;

        isLocked = true;
        setButtonState();

        for (let i = 0; i < drawCount; i += 1) {
          await sleep(DRAW_DELAY);
          const next = getUniqueRandom(currentRound);
          currentRound.push(next);
          renderCurrentRound(currentRound);
        }

        if (isRoundComplete()) {
          sortCurrentRoundWithAnimation();
        }

        isLocked = false;
        setButtonState();
      }

      function resetPointerState() {
        pressStartAt = null;
        activePointerId = null;
      }

      drawBtn.addEventListener('pointerdown', (event) => {
        if (isLocked) return;
        event.preventDefault();

        if (typeof drawBtn.setPointerCapture === 'function') {
          try { drawBtn.setPointerCapture(event.pointerId); } catch (_) {}
        }

        pressStartAt = performance.now();
        activePointerId = event.pointerId;
      });

      drawBtn.addEventListener('pointerup', async (event) => {
        if (activePointerId !== null && event.pointerId !== activePointerId) return;
        if (pressStartAt === null || isLocked) {
          resetPointerState();
          return;
        }

        const duration = performance.now() - pressStartAt;
        resetPointerState();

        if (isRoundComplete()) {
          startNextRound();
          setButtonState();
          return;
        }

        if (duration >= LONG_PRESS_MS) {
          await drawMultiple(MAX_PER_ROUND);
        } else {
          await drawMultiple(1);
        }
      });

      drawBtn.addEventListener('pointercancel', () => {
        resetPointerState();
      });

      drawBtn.addEventListener('lostpointercapture', () => {
        resetPointerState();
      });

      renderHistory();
      setButtonState();
    </script>
  </body>
</html>

